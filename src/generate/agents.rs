use crate::types::FileEntry;

pub fn generate_agents_md(
    large_files: &[FileEntry],
    critical_files: &[(String, usize)],
    entry_points: &[String],
) -> String {
    let mut output = String::new();

    output.push_str("# AGENTS.md\n\n");
    output.push_str("Instructions for AI agents working with this codebase.\n\n");

    output.push_str("## Reading Protocol\n\n");
    output.push_str("**MUST**:\n");
    output.push_str("- Read `outline.md` before exploring large files\n");
    output.push_str("- Check `memory.md` for warnings and business rules\n");
    output.push_str("- Start from entry points listed below\n\n");

    output.push_str("**ALWAYS**:\n");
    output.push_str("- Respect existing patterns in the codebase\n");
    output.push_str("- Check for TODOs before implementing new features in the same area\n");
    output.push_str("- Verify changes don't violate documented invariants\n\n");

    output.push_str("**NEVER**:\n");
    output.push_str("- Skip reading `memory.md` warnings before modifying related code\n");
    output.push_str("- Ignore SAFETY comments in unsafe blocks\n");
    output.push_str("- Delete TODO/FIXME without resolving or consulting\n\n");

    output.push_str("---\n\n");

    if !entry_points.is_empty() {
        output.push_str("## Entry Points\n\n");
        output.push_str("Start reading the codebase from these files:\n\n");
        for ep in entry_points {
            output.push_str(&format!("- `{}`\n", ep));
        }
        output.push_str("\n");
    }

    if !large_files.is_empty() {
        output.push_str("## Large Files (Consult outline.md)\n\n");
        output.push_str(
            "These files exceed the line threshold. Use `outline.md` for symbol maps:\n\n",
        );
        output.push_str("| File | Lines | Language |\n");
        output.push_str("| ---- | ----- | -------- |\n");
        for f in large_files {
            output.push_str(&format!(
                "| `{}` | {} | {:?} |\n",
                f.relative_path, f.line_count, f.language
            ));
        }
        output.push_str("\n");
    }

    if !critical_files.is_empty() {
        output.push_str("## Critical Files (Review memory.md First)\n\n");
        output.push_str("These files contain high-priority warnings or business rules:\n\n");
        output.push_str("| File | High-Priority Markers |\n");
        output.push_str("| ---- | --------------------- |\n");
        for (path, count) in critical_files {
            output.push_str(&format!("| `{}` | {} |\n", path, count));
        }
        output.push_str("\n");
    }

    output.push_str("---\n\n");
    output.push_str("*Generated by [agentmap](https://github.com/yourusername/agentmap)*\n");

    output
}

pub fn detect_entry_points(files: &[FileEntry]) -> Vec<String> {
    let entry_patterns = [
        "main.rs",
        "lib.rs",
        "mod.rs",
        "index.js",
        "index.ts",
        "index.tsx",
        "main.py",
        "__init__.py",
        "app.py",
        "main.go",
        "cmd/main.go",
    ];

    let mut entry_points: Vec<String> = files
        .iter()
        .filter(|f| {
            entry_patterns.iter().any(|pat| {
                f.relative_path.ends_with(pat)
                    || f.relative_path == *pat
                    || f.path
                        .file_name()
                        .map(|n| n.to_string_lossy())
                        .is_some_and(|n| *pat == n)
            })
        })
        .map(|f| f.relative_path.clone())
        .collect();

    entry_points.sort();
    entry_points.dedup();

    if entry_points.iter().any(|p| p.ends_with("lib.rs")) {
        entry_points.retain(|p| !p.ends_with("mod.rs") || p == "src/mod.rs");
    }

    entry_points
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Language;
    use std::path::PathBuf;

    fn make_file(relative_path: &str, line_count: usize) -> FileEntry {
        FileEntry {
            path: PathBuf::from(relative_path),
            relative_path: relative_path.to_string(),
            extension: relative_path.split('.').last().map(|s| s.to_string()),
            language: Language::Rust,
            size_bytes: 1000,
            line_count,
            is_large: line_count > 500,
        }
    }

    #[test]
    fn test_empty_agents_md() {
        let result = generate_agents_md(&[], &[], &[]);
        assert!(result.contains("# AGENTS.md"));
        assert!(result.contains("Reading Protocol"));
    }

    #[test]
    fn test_with_large_files() {
        let large = vec![make_file("src/big.rs", 1000)];
        let result = generate_agents_md(&large, &[], &[]);
        assert!(result.contains("Large Files"));
        assert!(result.contains("src/big.rs"));
    }

    #[test]
    fn test_entry_point_detection() {
        let files = vec![
            make_file("src/main.rs", 100),
            make_file("src/lib.rs", 200),
            make_file("src/utils/mod.rs", 50),
        ];

        let entries = detect_entry_points(&files);
        assert!(entries.contains(&"src/main.rs".to_string()));
        assert!(entries.contains(&"src/lib.rs".to_string()));
    }
}

use crate::scan::DiffStat;
use crate::types::FileEntry;

pub struct AgentsConfig<'a> {
    pub large_files: &'a [FileEntry],
    pub critical_files: &'a [(String, usize)],
    pub entry_points: &'a [String],
    pub hub_files: &'a [(String, usize)],
    pub diff_stats: Option<&'a [DiffStat]>,
    pub diff_base: Option<&'a str>,
}

pub fn generate_agents_md(config: &AgentsConfig) -> String {
    let mut output = String::new();

    output.push_str("# AGENTS.md\n\n");
    output.push_str("Instructions for AI agents working with this codebase.\n\n");

    if let (Some(stats), Some(base)) = (config.diff_stats, config.diff_base) {
        if !stats.is_empty() {
            output.push_str(&format!("## Changes vs `{}`\n\n", base));
            output.push_str("Files changed in this branch:\n\n");
            output.push_str("| File | Status | Changes |\n");
            output.push_str("| ---- | ------ | ------- |\n");
            for stat in stats {
                let changes = if stat.additions > 0 || stat.deletions > 0 {
                    format!("+{} -{}", stat.additions, stat.deletions)
                } else {
                    "-".to_string()
                };
                output.push_str(&format!(
                    "| `{}` | {} | {} |\n",
                    stat.path,
                    stat.status.as_str(),
                    changes
                ));
            }
            output.push_str("\n---\n\n");
        }
    }

    output.push_str("## Reading Protocol\n\n");
    output.push_str("**MUST**:\n");
    output.push_str("- Read `outline.md` before exploring large files\n");
    output.push_str("- Check `memory.md` for warnings and business rules\n");
    output.push_str("- Start from entry points listed below\n\n");

    output.push_str("**ALWAYS**:\n");
    output.push_str("- Respect existing patterns in the codebase\n");
    output.push_str("- Check for TODOs before implementing new features in the same area\n");
    output.push_str("- Verify changes don't violate documented invariants\n\n");

    output.push_str("**NEVER**:\n");
    output.push_str("- Skip reading `memory.md` warnings before modifying related code\n");
    output.push_str("- Ignore SAFETY comments in unsafe blocks\n");
    output.push_str("- Delete TODO/FIXME without resolving or consulting\n\n");

    output.push_str("---\n\n");

    if !config.entry_points.is_empty() {
        output.push_str("## Entry Points\n\n");
        output.push_str("Start reading the codebase from these files:\n\n");
        for ep in config.entry_points {
            output.push_str(&format!("- `{}`\n", ep));
        }
        output.push_str("\n");
    }

    if !config.large_files.is_empty() {
        output.push_str("## Large Files (Consult outline.md)\n\n");
        output.push_str(
            "These files exceed the line threshold. Use `outline.md` for symbol maps:\n\n",
        );
        output.push_str("| File | Lines | Language |\n");
        output.push_str("| ---- | ----- | -------- |\n");
        for f in config.large_files {
            output.push_str(&format!(
                "| `{}` | {} | {:?} |\n",
                f.relative_path, f.line_count, f.language
            ));
        }
        output.push_str("\n");
    }

    if !config.critical_files.is_empty() {
        output.push_str("## Critical Files (Review memory.md First)\n\n");
        output.push_str("These files contain high-priority warnings or business rules:\n\n");
        output.push_str("| File | High-Priority Markers |\n");
        output.push_str("| ---- | --------------------- |\n");
        for (path, count) in config.critical_files {
            output.push_str(&format!("| `{}` | {} |\n", path, count));
        }
        output.push_str("\n");
    }

    if !config.hub_files.is_empty() {
        output.push_str("## Hub Files (High Import Count)\n\n");
        output.push_str(
            "These files are imported by many others. Changes here have wide impact:\n\n",
        );
        output.push_str("| File | Imported By |\n");
        output.push_str("| ---- | ----------- |\n");
        for (path, count) in config.hub_files {
            output.push_str(&format!("| `{}` | {} files |\n", path, count));
        }
        output.push_str("\n");
    }

    output.push_str("---\n\n");
    output.push_str("*Generated by [agentmap](https://github.com/yourusername/agentmap)*\n");

    output
}

pub fn detect_entry_points(files: &[FileEntry]) -> Vec<String> {
    let entry_patterns = [
        "main.rs",
        "lib.rs",
        "mod.rs",
        "index.js",
        "index.ts",
        "index.tsx",
        "main.py",
        "__init__.py",
        "app.py",
        "main.go",
        "cmd/main.go",
    ];

    let mut entry_points: Vec<String> = files
        .iter()
        .filter(|f| {
            entry_patterns.iter().any(|pat| {
                f.relative_path.ends_with(pat)
                    || f.relative_path == *pat
                    || f.path
                        .file_name()
                        .map(|n| n.to_string_lossy())
                        .is_some_and(|n| *pat == n)
            })
        })
        .map(|f| f.relative_path.clone())
        .collect();

    entry_points.sort();
    entry_points.dedup();

    if entry_points.iter().any(|p| p.ends_with("lib.rs")) {
        entry_points.retain(|p| !p.ends_with("mod.rs") || p == "src/mod.rs");
    }

    entry_points
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Language;
    use std::path::PathBuf;

    fn make_file(relative_path: &str, line_count: usize) -> FileEntry {
        FileEntry {
            path: PathBuf::from(relative_path),
            relative_path: relative_path.to_string(),
            extension: relative_path.split('.').last().map(|s| s.to_string()),
            language: Language::Rust,
            size_bytes: 1000,
            line_count,
            is_large: line_count > 500,
        }
    }

    #[test]
    fn test_empty_agents_md() {
        let config = AgentsConfig {
            large_files: &[],
            critical_files: &[],
            entry_points: &[],
            hub_files: &[],
            diff_stats: None,
            diff_base: None,
        };
        let result = generate_agents_md(&config);
        assert!(result.contains("# AGENTS.md"));
        assert!(result.contains("Reading Protocol"));
    }

    #[test]
    fn test_with_large_files() {
        let large = vec![make_file("src/big.rs", 1000)];
        let config = AgentsConfig {
            large_files: &large,
            critical_files: &[],
            entry_points: &[],
            hub_files: &[],
            diff_stats: None,
            diff_base: None,
        };
        let result = generate_agents_md(&config);
        assert!(result.contains("Large Files"));
        assert!(result.contains("src/big.rs"));
    }

    #[test]
    fn test_with_hub_files() {
        let hubs = vec![
            ("src/utils.rs".to_string(), 5),
            ("src/types.rs".to_string(), 3),
        ];
        let config = AgentsConfig {
            large_files: &[],
            critical_files: &[],
            entry_points: &[],
            hub_files: &hubs,
            diff_stats: None,
            diff_base: None,
        };
        let result = generate_agents_md(&config);
        assert!(result.contains("Hub Files"));
        assert!(result.contains("src/utils.rs"));
        assert!(result.contains("5 files"));
    }

    #[test]
    fn test_with_diff_stats() {
        use crate::scan::DiffStatus;
        let stats = vec![
            DiffStat {
                path: "src/new.rs".to_string(),
                status: DiffStatus::Added,
                additions: 100,
                deletions: 0,
            },
            DiffStat {
                path: "src/old.rs".to_string(),
                status: DiffStatus::Modified,
                additions: 10,
                deletions: 5,
            },
        ];
        let config = AgentsConfig {
            large_files: &[],
            critical_files: &[],
            entry_points: &[],
            hub_files: &[],
            diff_stats: Some(&stats),
            diff_base: Some("main"),
        };
        let result = generate_agents_md(&config);
        assert!(result.contains("Changes vs `main`"));
        assert!(result.contains("src/new.rs"));
        assert!(result.contains("+100 -0"));
        assert!(result.contains("new"));
    }

    #[test]
    fn test_entry_point_detection() {
        let files = vec![
            make_file("src/main.rs", 100),
            make_file("src/lib.rs", 200),
            make_file("src/utils/mod.rs", 50),
        ];

        let entries = detect_entry_points(&files);
        assert!(entries.contains(&"src/main.rs".to_string()));
        assert!(entries.contains(&"src/lib.rs".to_string()));
    }
}

//! INDEX.md generator for hierarchical content architecture.
//!
//! Generates a constant-size O(m) routing table where m = number of modules,
//! regardless of total file count in the repository.

use crate::analyze::ModuleInfo;
use crate::types::MemoryEntry;

/// Configuration for INDEX.md generation
pub struct IndexConfig<'a> {
    /// Detected modules
    pub modules: &'a [ModuleInfo],
    /// All memory entries (for warning counts)
    pub memory_entries: &'a [MemoryEntry],
    /// Global entry points (top 5 max)
    pub entry_points: &'a [String],
    /// Hub modules (modules with high import count)
    pub hub_modules: &'a [(String, usize)],
    /// Project name (from directory or git)
    pub project_name: Option<&'a str>,
}

/// Generate INDEX.md content
pub fn generate_index_md(config: &IndexConfig) -> String {
    let mut output = String::new();

    // Header
    let project_name = config.project_name.unwrap_or("Project");
    output.push_str(&format!("# {}\n\n", project_name));

    // Reading protocol
    output.push_str("## Reading Protocol\n\n");
    output.push_str("**Start here**, then navigate to specific modules.\n\n");
    output.push_str("1. Read this INDEX for overview\n");
    output.push_str("2. Go to relevant `modules/{name}/MODULE.md`\n");
    output.push_str("3. Check module's `outline.md` for large files\n");
    output.push_str("4. Check module's `memory.md` for warnings\n\n");

    // Entry points (max 5)
    if !config.entry_points.is_empty() {
        output.push_str("## Entry Points\n\n");
        for ep in config.entry_points.iter().take(5) {
            output.push_str(&format!("- `{}`\n", ep));
        }
        output.push('\n');
    }

    // Critical alerts summary
    let warning_count = count_high_priority_warnings(config.memory_entries);
    if warning_count > 0 {
        output.push_str("## ⚠️ Critical Alerts\n\n");
        output.push_str(&format!(
            "**{}** high-priority warnings across {} modules. ",
            warning_count,
            count_modules_with_warnings(config.modules, config.memory_entries)
        ));
        output.push_str("Check each module's `memory.md` for details.\n\n");
    }

    // Module table
    output.push_str("## Modules\n\n");

    if config.modules.is_empty() {
        output.push_str("_No modules detected._\n\n");
    } else {
        output.push_str("| Module | Type | Files | Warnings | Hub |\n");
        output.push_str("| ------ | ---- | ----- | -------- | --- |\n");

        // Sort modules by path for consistent output
        let mut sorted_modules: Vec<_> = config.modules.iter().collect();
        sorted_modules.sort_by(|a, b| a.path.cmp(&b.path));

        for module in sorted_modules {
            let warning_count = count_module_warnings(module, config.memory_entries);
            let is_hub = config
                .hub_modules
                .iter()
                .any(|(path, _)| *path == module.path);
            let hub_indicator = if is_hub { "★" } else { "" };
            let warning_str = if warning_count > 0 {
                format!("{}", warning_count)
            } else {
                "-".to_string()
            };

            let module_link = if module.slug == "root" {
                "[root](modules/root/MODULE.md)".to_string()
            } else {
                format!("[{}](modules/{}/MODULE.md)", module.path, module.slug)
            };

            output.push_str(&format!(
                "| {} | {} | {} | {} | {} |\n",
                module_link,
                module.boundary_type.as_str(),
                module.file_count(),
                warning_str,
                hub_indicator
            ));
        }
        output.push('\n');
    }

    // Footer
    output.push_str("---\n\n");
    output.push_str("*Generated by [agentmap](https://github.com/nguyenphutrong/agentmap)*\n");

    output
}

/// Count high-priority (Warning, Safety, Rule) memory entries
fn count_high_priority_warnings(entries: &[MemoryEntry]) -> usize {
    use crate::types::Priority;
    entries
        .iter()
        .filter(|e| e.priority == Priority::High)
        .count()
}

/// Count modules that have at least one warning
fn count_modules_with_warnings(modules: &[ModuleInfo], entries: &[MemoryEntry]) -> usize {
    modules
        .iter()
        .filter(|m| count_module_warnings(m, entries) > 0)
        .count()
}

/// Count warnings in a specific module
fn count_module_warnings(module: &ModuleInfo, entries: &[MemoryEntry]) -> usize {
    use crate::types::Priority;
    entries
        .iter()
        .filter(|e| {
            e.priority == Priority::High
                && module
                    .files
                    .iter()
                    .any(|f| e.source_file.starts_with(f) || *f == e.source_file)
        })
        .count()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyze::BoundaryType;
    use crate::types::{MemoryKind, Priority};

    fn make_module(path: &str, files: Vec<String>) -> ModuleInfo {
        let mut module = ModuleInfo::new(path, BoundaryType::RustModule, None);
        for f in files {
            module.add_file(f);
        }
        module
    }

    fn make_warning(file: &str) -> MemoryEntry {
        MemoryEntry {
            kind: MemoryKind::Warning,
            content: "Test warning".to_string(),
            source_file: file.to_string(),
            line_number: 10,
            priority: Priority::High,
        }
    }

    #[test]
    fn test_generate_index_md_basic() {
        let modules = vec![make_module("src", vec!["src/lib.rs".to_string()])];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &[],
            entry_points: &["src/main.rs".to_string()],
            hub_modules: &[],
            project_name: Some("TestProject"),
        };

        let result = generate_index_md(&config);

        assert!(result.contains("# TestProject"));
        assert!(result.contains("## Entry Points"));
        assert!(result.contains("src/main.rs"));
        assert!(result.contains("## Modules"));
        assert!(result.contains("[src](modules/src/MODULE.md)"));
    }

    #[test]
    fn test_generate_index_md_with_warnings() {
        let modules = vec![make_module("src/auth", vec!["src/auth/mod.rs".to_string()])];
        let warnings = vec![make_warning("src/auth/mod.rs")];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &warnings,
            entry_points: &[],
            hub_modules: &[],
            project_name: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("⚠️ Critical Alerts"));
        assert!(result.contains("**1** high-priority warnings"));
    }

    #[test]
    fn test_generate_index_md_with_hub() {
        let modules = vec![make_module(
            "src/utils",
            vec!["src/utils/mod.rs".to_string()],
        )];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &[],
            entry_points: &[],
            hub_modules: &[("src/utils".to_string(), 10)],
            project_name: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("★")); // Hub indicator
    }

    #[test]
    fn test_entry_points_limited_to_5() {
        let entry_points: Vec<String> = (0..10).map(|i| format!("file{}.rs", i)).collect();

        let config = IndexConfig {
            modules: &[],
            memory_entries: &[],
            entry_points: &entry_points,
            hub_modules: &[],
            project_name: None,
        };

        let result = generate_index_md(&config);

        // Should only contain first 5
        assert!(result.contains("file0.rs"));
        assert!(result.contains("file4.rs"));
        assert!(!result.contains("file5.rs"));
    }

    #[test]
    fn test_empty_modules() {
        let config = IndexConfig {
            modules: &[],
            memory_entries: &[],
            entry_points: &[],
            hub_modules: &[],
            project_name: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("_No modules detected._"));
    }
}

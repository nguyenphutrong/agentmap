//! INDEX.md generator for hierarchical content architecture.
//!
//! Generates a constant-size O(m) routing table where m = number of modules,
//! regardless of total file count in the repository.

use crate::analyze::{FileGraph, ModuleInfo};
use crate::types::{FileEntry, MemoryEntry};
use std::collections::{HashMap, HashSet};

/// Configuration for INDEX.md generation
pub struct IndexConfig<'a> {
    /// Detected modules
    pub modules: &'a [ModuleInfo],
    /// All memory entries (for warning counts)
    pub memory_entries: &'a [MemoryEntry],
    /// Global entry points (top 5 max)
    pub entry_points: &'a [String],
    /// Hub modules (modules with high import count)
    pub hub_modules: &'a [(String, usize)],
    /// Project name (from directory or git)
    pub project_name: Option<&'a str>,
    /// File dependency graph (optional, for Mermaid diagram)
    pub file_graph: Option<&'a FileGraph>,
}

/// Generate INDEX.md content
pub fn generate_index_md(config: &IndexConfig) -> String {
    let mut output = String::new();

    // Header
    let project_name = config.project_name.unwrap_or("Project");
    output.push_str(&format!("# {}\n\n", project_name));

    // Reading protocol
    output.push_str("## Reading Protocol\n\n");
    output.push_str("**Start here**, then navigate to specific modules.\n\n");
    output.push_str("1. Read this INDEX for overview\n");
    output.push_str("2. Go to relevant `modules/{name}/MODULE.md`\n");
    output.push_str("3. Check module's `outline.md` for large files\n");
    output.push_str("4. Check module's `memory.md` for warnings\n\n");

    // Entry points (max 5)
    if !config.entry_points.is_empty() {
        output.push_str("## Entry Points\n\n");
        for ep in config.entry_points.iter().take(5) {
            output.push_str(&format!("- `{}`\n", ep));
        }
        output.push('\n');
    }

    // Critical alerts summary
    let warning_count = count_high_priority_warnings(config.memory_entries);
    if warning_count > 0 {
        output.push_str("## ⚠️ Critical Alerts\n\n");
        output.push_str(&format!(
            "**{}** high-priority warnings across {} modules. ",
            warning_count,
            count_modules_with_warnings(config.modules, config.memory_entries)
        ));
        output.push_str("Check each module's `memory.md` for details.\n\n");
    }

    // Module table
    output.push_str("## Modules\n\n");

    if config.modules.is_empty() {
        output.push_str("_No modules detected._\n\n");
    } else {
        output.push_str("| Module | Type | Files | Warnings | Hub |\n");
        output.push_str("| ------ | ---- | ----- | -------- | --- |\n");

        // Sort modules by path for consistent output
        let mut sorted_modules: Vec<_> = config.modules.iter().collect();
        sorted_modules.sort_by(|a, b| a.path.cmp(&b.path));

        for module in sorted_modules {
            let warning_count = count_module_warnings(module, config.memory_entries);
            let is_hub = config
                .hub_modules
                .iter()
                .any(|(path, _)| *path == module.path);
            let hub_indicator = if is_hub { "★" } else { "" };
            let warning_str = if warning_count > 0 {
                format!("{}", warning_count)
            } else {
                "-".to_string()
            };

            let module_link = if module.slug == "root" {
                "[root](modules/root/MODULE.md)".to_string()
            } else {
                format!("[{}](modules/{}/MODULE.md)", module.path, module.slug)
            };

            output.push_str(&format!(
                "| {} | {} | {} | {} | {} |\n",
                module_link,
                module.boundary_type.as_str(),
                module.file_count(),
                warning_str,
                hub_indicator
            ));
        }
        output.push('\n');
    }

    // Module dependency graph (Mermaid)
    if let Some(graph) = config.file_graph {
        let module_deps = compute_module_dependencies(config.modules, graph);
        if !module_deps.is_empty() {
            output.push_str("## Module Dependencies\n\n");
            output.push_str("```mermaid\ngraph TD\n");
            for (from_module, to_module) in &module_deps {
                let from_id = sanitize_mermaid_id(from_module);
                let to_id = sanitize_mermaid_id(to_module);
                output.push_str(&format!(
                    "    {}[{}] --> {}[{}]\n",
                    from_id, from_module, to_id, to_module
                ));
            }
            output.push_str("```\n\n");
        }
    }

    // Footer
    output.push_str("---\n\n");
    output.push_str("*Generated by [agentlens](https://github.com/nguyenphutrong/agentlens)*\n");

    output
}

/// Count high-priority (Warning, Safety, Rule) memory entries
fn count_high_priority_warnings(entries: &[MemoryEntry]) -> usize {
    use crate::types::Priority;
    entries
        .iter()
        .filter(|e| e.priority == Priority::High)
        .count()
}

/// Count modules that have at least one warning
fn count_modules_with_warnings(modules: &[ModuleInfo], entries: &[MemoryEntry]) -> usize {
    modules
        .iter()
        .filter(|m| count_module_warnings(m, entries) > 0)
        .count()
}

/// Count warnings in a specific module
fn count_module_warnings(module: &ModuleInfo, entries: &[MemoryEntry]) -> usize {
    use crate::types::Priority;
    entries
        .iter()
        .filter(|e| {
            e.priority == Priority::High
                && module
                    .files
                    .iter()
                    .any(|f| e.source_file.starts_with(f) || *f == e.source_file)
        })
        .count()
}

fn compute_module_dependencies(modules: &[ModuleInfo], graph: &FileGraph) -> Vec<(String, String)> {
    let mut deps: HashSet<(String, String)> = HashSet::new();

    let file_to_module: HashMap<&str, &str> = modules
        .iter()
        .flat_map(|m| m.files.iter().map(move |f| (f.as_str(), m.slug.as_str())))
        .collect();

    for module in modules {
        for file in &module.files {
            if let Some(imports) = graph.imports.get(file) {
                for imp in imports {
                    if let Some(&target_module) = file_to_module.get(imp.as_str()) {
                        if target_module != module.slug {
                            deps.insert((module.slug.clone(), target_module.to_string()));
                        }
                    }
                }
            }
        }
    }

    let mut result: Vec<_> = deps.into_iter().collect();
    result.sort();
    result
}

fn sanitize_mermaid_id(s: &str) -> String {
    s.chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect()
}

/// Detect entry point files from the file list
pub fn detect_entry_points(files: &[FileEntry]) -> Vec<String> {
    let entry_patterns = [
        "main.rs",
        "lib.rs",
        "mod.rs",
        "index.js",
        "index.ts",
        "index.tsx",
        "main.py",
        "__init__.py",
        "app.py",
        "main.go",
        "cmd/main.go",
    ];

    let mut entry_points: Vec<String> = files
        .iter()
        .filter(|f| {
            entry_patterns.iter().any(|pat| {
                f.relative_path.ends_with(pat)
                    || f.relative_path == *pat
                    || f.path
                        .file_name()
                        .map(|n| n.to_string_lossy())
                        .is_some_and(|n| *pat == n)
            })
        })
        .map(|f| f.relative_path.clone())
        .collect();

    entry_points.sort();
    entry_points.dedup();

    if entry_points.iter().any(|p| p.ends_with("lib.rs")) {
        entry_points.retain(|p| !p.ends_with("mod.rs") || p == "src/mod.rs");
    }

    entry_points
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyze::BoundaryType;
    use crate::types::{Language, MemoryKind, Priority};

    fn make_module(path: &str, files: Vec<String>) -> ModuleInfo {
        let mut module = ModuleInfo::new(path, BoundaryType::RustModule, None);
        for f in files {
            module.add_file(f);
        }
        module
    }

    fn make_warning(file: &str) -> MemoryEntry {
        MemoryEntry {
            kind: MemoryKind::Warning,
            content: "Test warning".to_string(),
            source_file: file.to_string(),
            line_number: 10,
            priority: Priority::High,
        }
    }

    #[test]
    fn test_generate_index_md_basic() {
        let modules = vec![make_module("src", vec!["src/lib.rs".to_string()])];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &[],
            entry_points: &["src/main.rs".to_string()],
            hub_modules: &[],
            project_name: Some("TestProject"),
            file_graph: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("# TestProject"));
        assert!(result.contains("## Entry Points"));
        assert!(result.contains("src/main.rs"));
        assert!(result.contains("## Modules"));
        assert!(result.contains("[src](modules/src/MODULE.md)"));
    }

    #[test]
    fn test_generate_index_md_with_warnings() {
        let modules = vec![make_module("src/auth", vec!["src/auth/mod.rs".to_string()])];
        let warnings = vec![make_warning("src/auth/mod.rs")];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &warnings,
            entry_points: &[],
            hub_modules: &[],
            project_name: None,
            file_graph: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("⚠️ Critical Alerts"));
        assert!(result.contains("**1** high-priority warnings"));
    }

    #[test]
    fn test_generate_index_md_with_hub() {
        let modules = vec![make_module(
            "src/utils",
            vec!["src/utils/mod.rs".to_string()],
        )];

        let config = IndexConfig {
            modules: &modules,
            memory_entries: &[],
            entry_points: &[],
            hub_modules: &[("src/utils".to_string(), 10)],
            project_name: None,
            file_graph: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("★")); // Hub indicator
    }

    #[test]
    fn test_entry_points_limited_to_5() {
        let entry_points: Vec<String> = (0..10).map(|i| format!("file{}.rs", i)).collect();

        let config = IndexConfig {
            modules: &[],
            memory_entries: &[],
            entry_points: &entry_points,
            hub_modules: &[],
            project_name: None,
            file_graph: None,
        };

        let result = generate_index_md(&config);

        // Should only contain first 5
        assert!(result.contains("file0.rs"));
        assert!(result.contains("file4.rs"));
        assert!(!result.contains("file5.rs"));
    }

    #[test]
    fn test_empty_modules() {
        let config = IndexConfig {
            modules: &[],
            memory_entries: &[],
            entry_points: &[],
            hub_modules: &[],
            project_name: None,
            file_graph: None,
        };

        let result = generate_index_md(&config);

        assert!(result.contains("_No modules detected._"));
    }

    fn make_file(relative_path: &str, line_count: usize) -> FileEntry {
        use std::path::PathBuf;
        FileEntry {
            path: PathBuf::from(relative_path),
            relative_path: relative_path.to_string(),
            extension: relative_path.split('.').last().map(|s| s.to_string()),
            language: Language::Rust,
            size_bytes: 1000,
            line_count,
            is_large: line_count > 500,
        }
    }

    #[test]
    fn test_entry_point_detection() {
        let files = vec![
            make_file("src/main.rs", 100),
            make_file("src/lib.rs", 200),
            make_file("src/utils/mod.rs", 50),
        ];

        let entries = detect_entry_points(&files);
        assert!(entries.contains(&"src/main.rs".to_string()));
        assert!(entries.contains(&"src/lib.rs".to_string()));
    }
}

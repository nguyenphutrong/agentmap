//! AGENT.md generator for AI agent instructions.
//!
//! Generates an instruction file that teaches AI agents how to effectively
//! use agentlens documentation, ensuring consistent and optimal behavior.

use crate::analyze::ModuleInfo;
use chrono::{DateTime, Utc};

/// Configuration for AGENT.md generation
pub struct AgentConfig<'a> {
    /// Detected modules with descriptions
    pub modules: &'a [ModuleInfo],
    /// Total file count for project size classification
    pub total_files: usize,
    /// Total warning count
    pub warning_count: usize,
    /// Git HEAD commit hash (short, 7 chars)
    pub git_head: Option<&'a str>,
    /// Generation timestamp (Unix seconds)
    pub generated_at: u64,
    /// Project name
    pub project_name: Option<&'a str>,
}

/// Project size classification for content adaptation
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ProjectSize {
    /// < 20 files - minimal guidance
    Small,
    /// 20-100 files - standard guidance
    Medium,
    /// > 100 files - detailed guidance
    Large,
}

impl ProjectSize {
    pub fn from_file_count(count: usize) -> Self {
        if count < 20 {
            ProjectSize::Small
        } else if count <= 100 {
            ProjectSize::Medium
        } else {
            ProjectSize::Large
        }
    }
}

/// Generate AGENT.md content
pub fn generate_agent_md(config: &AgentConfig) -> String {
    let mut output = String::new();
    let project_size = ProjectSize::from_file_count(config.total_files);

    output.push_str("# AI Agent Instructions\n\n");

    if let Some(name) = config.project_name {
        output.push_str(&format!(
            "Instructions for working with the **{}** codebase.\n\n",
            name
        ));
    }

    output.push_str("## Reading Protocol\n\n");
    generate_reading_protocol(&mut output, project_size);

    output.push_str("## Freshness Check\n\n");
    generate_freshness_section(&mut output, config);

    if !config.modules.is_empty() {
        output.push_str("## Available Modules\n\n");
        generate_modules_section(&mut output, config.modules, project_size);
    }

    output.push_str("## When Docs Seem Stale\n\n");
    generate_stale_guidance(&mut output);

    if project_size == ProjectSize::Large {
        output.push_str("## Quick Reference\n\n");
        generate_quick_reference(&mut output, config);
    }

    output.push_str("---\n\n");
    output.push_str("*Generated by [agentlens](https://github.com/nguyenphutrong/agentlens)*\n");

    output
}

fn generate_reading_protocol(output: &mut String, project_size: ProjectSize) {
    output.push_str("Follow this protocol to understand the codebase efficiently:\n\n");

    output.push_str(
        "1. **Start with INDEX.md** - Get the project overview and module routing table\n",
    );
    output.push_str("2. **Navigate to relevant module** - Go to `modules/{name}/MODULE.md` for the area you're working on\n");
    output.push_str(
        "3. **Check memory.md before editing** - Review warnings and TODOs for that module\n",
    );
    output.push_str(
        "4. **Use outline.md for large files** - Find symbols without reading entire files\n",
    );

    if project_size == ProjectSize::Large {
        output.push_str(
            "5. **Check imports.md for dependencies** - Understand module relationships before changes\n",
        );
        output.push_str(
            "6. **Review files/*.md for complex files** - Deep documentation for high-complexity files\n\n",
        );
    } else {
        output.push('\n');
    }

    output.push_str("### Documentation Structure\n\n");
    output.push_str("```\n");
    output.push_str(".agentlens/\n");
    output.push_str("├── INDEX.md              # Start here - project overview\n");
    output.push_str("├── AGENT.md              # This file - AI instructions\n");
    output.push_str("├── modules/\n");
    output.push_str("│   └── {module-slug}/\n");
    output.push_str("│       ├── MODULE.md     # Module summary and file list\n");
    output.push_str("│       ├── outline.md    # Symbol maps for large files\n");
    output.push_str("│       ├── memory.md     # Warnings and TODOs\n");
    output.push_str("│       └── imports.md    # Dependencies\n");
    output.push_str("└── files/                # Deep docs for complex files\n");
    output.push_str("```\n\n");
}

fn generate_freshness_section(output: &mut String, config: &AgentConfig) {
    let timestamp = DateTime::<Utc>::from_timestamp(config.generated_at as i64, 0)
        .map(|dt| dt.format("%Y-%m-%dT%H:%M:%SZ").to_string())
        .unwrap_or_else(|| "Unknown".to_string());

    output.push_str(&format!("**Generated:** {}\n", timestamp));

    if let Some(head) = config.git_head {
        output.push_str(&format!("**Git HEAD:** `{}`\n", head));
    }

    output.push('\n');

    output.push_str("### How to verify freshness\n\n");
    output.push_str("1. Compare the Git HEAD above with current: `git rev-parse --short HEAD`\n");
    output.push_str("2. If they differ significantly, docs may be outdated\n");
    output.push_str("3. Check file modification times vs. the Generated timestamp\n\n");
}

fn generate_modules_section(
    output: &mut String,
    modules: &[ModuleInfo],
    project_size: ProjectSize,
) {
    let mut sorted_modules: Vec<_> = modules.iter().collect();
    sorted_modules.sort_by(|a, b| a.path.cmp(&b.path));

    if project_size == ProjectSize::Small {
        for module in sorted_modules {
            output.push_str(&format!(
                "- **{}** ({} files)\n",
                module.path,
                module.file_count()
            ));
        }
    } else {
        output.push_str("| Module | Files | Type | Description |\n");
        output.push_str("| ------ | ----- | ---- | ----------- |\n");

        for module in sorted_modules {
            let description = infer_module_description(&module.path);
            output.push_str(&format!(
                "| `{}` | {} | {} | {} |\n",
                module.path,
                module.file_count(),
                module.boundary_type.as_str(),
                description
            ));
        }
    }
    output.push('\n');
}

fn generate_stale_guidance(output: &mut String) {
    output.push_str("If documentation seems outdated or inconsistent with the code:\n\n");
    output.push_str("1. **Regenerate docs:**\n");
    output.push_str("   ```bash\n");
    output.push_str("   agentlens\n");
    output.push_str("   ```\n\n");
    output.push_str("2. **Regenerate with diff mode** (faster, only changed files):\n");
    output.push_str("   ```bash\n");
    output.push_str("   agentlens --diff main\n");
    output.push_str("   ```\n\n");
    output.push_str("3. **Check freshness status:**\n");
    output.push_str("   ```bash\n");
    output.push_str("   agentlens --check\n");
    output.push_str("   ```\n\n");
    output.push_str("4. **Force full regeneration** (ignore cache):\n");
    output.push_str("   ```bash\n");
    output.push_str("   agentlens --force\n");
    output.push_str("   ```\n\n");
}

fn generate_quick_reference(output: &mut String, config: &AgentConfig) {
    output.push_str("| Metric | Value |\n");
    output.push_str("| ------ | ----- |\n");
    output.push_str(&format!("| Total files | {} |\n", config.total_files));
    output.push_str(&format!("| Modules | {} |\n", config.modules.len()));
    output.push_str(&format!("| Warnings | {} |\n", config.warning_count));
    output.push('\n');
}

/// Infer a brief description for a module based on its path
fn infer_module_description(path: &str) -> &'static str {
    let path_lower = path.to_lowercase();
    let last_segment = path.rsplit('/').next().unwrap_or(path).to_lowercase();

    match last_segment.as_str() {
        "src" | "lib" => "Source root",
        "cli" | "cmd" => "Command-line interface",
        "api" => "API endpoints",
        "auth" | "authentication" => "Authentication logic",
        "db" | "database" => "Database layer",
        "models" | "entities" => "Data models",
        "utils" | "helpers" | "common" => "Utility functions",
        "config" | "settings" => "Configuration",
        "tests" | "test" | "__tests__" => "Test files",
        "types" => "Type definitions",
        "handlers" | "controllers" => "Request handlers",
        "services" => "Business logic services",
        "middleware" => "Middleware functions",
        "routes" | "router" => "Route definitions",
        "components" => "UI components",
        "hooks" => "React hooks",
        "pages" | "views" => "Page/view components",
        "store" | "state" => "State management",
        "styles" | "css" => "Styling",
        "assets" | "public" | "static" => "Static assets",
        "scripts" => "Build/utility scripts",
        "docs" | "documentation" => "Documentation",
        "analyze" | "analysis" => "Analysis/parsing logic",
        "generate" | "generator" => "Generation logic",
        "emit" | "output" => "Output/emission logic",
        "scan" | "scanner" => "File scanning",
        "lang" => "Language-specific handlers",
        _ => {
            if path_lower.contains("test") {
                "Test files"
            } else if path_lower.contains("mock") {
                "Mock/fixture data"
            } else if path_lower.contains("error") {
                "Error handling"
            } else {
                "Module"
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyze::BoundaryType;

    fn make_module(path: &str, file_count: usize) -> ModuleInfo {
        let mut module = ModuleInfo::new(path, BoundaryType::RustModule, None);
        for i in 0..file_count {
            module.add_file(format!("{}/file{}.rs", path, i));
        }
        module
    }

    #[test]
    fn test_project_size_classification() {
        assert_eq!(ProjectSize::from_file_count(5), ProjectSize::Small);
        assert_eq!(ProjectSize::from_file_count(19), ProjectSize::Small);
        assert_eq!(ProjectSize::from_file_count(20), ProjectSize::Medium);
        assert_eq!(ProjectSize::from_file_count(50), ProjectSize::Medium);
        assert_eq!(ProjectSize::from_file_count(100), ProjectSize::Medium);
        assert_eq!(ProjectSize::from_file_count(101), ProjectSize::Large);
        assert_eq!(ProjectSize::from_file_count(500), ProjectSize::Large);
    }

    #[test]
    fn test_generate_agent_md_basic() {
        let modules = vec![make_module("src", 3), make_module("src/cli", 5)];

        let config = AgentConfig {
            modules: &modules,
            total_files: 8,
            warning_count: 2,
            git_head: Some("abc1234"),
            generated_at: 1704067200,
            project_name: Some("TestProject"),
        };

        let result = generate_agent_md(&config);

        assert!(result.contains("# AI Agent Instructions"));
        assert!(result.contains("**TestProject**"));
        assert!(result.contains("## Reading Protocol"));
        assert!(result.contains("## Freshness Check"));
        assert!(result.contains("**Generated:**"));
        assert!(result.contains("**Git HEAD:** `abc1234`"));
        assert!(result.contains("## Available Modules"));
        assert!(result.contains("## When Docs Seem Stale"));
        assert!(result.contains("agentlens"));
    }

    #[test]
    fn test_generate_agent_md_large_project() {
        let modules: Vec<_> = (0..10)
            .map(|i| make_module(&format!("src/mod{}", i), 15))
            .collect();

        let config = AgentConfig {
            modules: &modules,
            total_files: 150,
            warning_count: 5,
            git_head: Some("def5678"),
            generated_at: 1704067200,
            project_name: None,
        };

        let result = generate_agent_md(&config);

        assert!(result.contains("## Quick Reference"));
        assert!(result.contains("| Total files | 150 |"));
        assert!(result.contains("| Modules | 10 |"));
        assert!(result.contains("| Warnings | 5 |"));
    }

    #[test]
    fn test_generate_agent_md_no_git_head() {
        let config = AgentConfig {
            modules: &[],
            total_files: 5,
            warning_count: 0,
            git_head: None,
            generated_at: 1704067200,
            project_name: None,
        };

        let result = generate_agent_md(&config);

        assert!(!result.contains("**Git HEAD:**"));
        assert!(result.contains("**Generated:**"));
    }

    #[test]
    fn test_infer_module_description() {
        assert_eq!(infer_module_description("src"), "Source root");
        assert_eq!(
            infer_module_description("src/cli"),
            "Command-line interface"
        );
        assert_eq!(infer_module_description("src/api"), "API endpoints");
        assert_eq!(infer_module_description("lib/utils"), "Utility functions");
        assert_eq!(
            infer_module_description("src/analyze"),
            "Analysis/parsing logic"
        );
        assert_eq!(infer_module_description("unknown/module"), "Module");
    }

    #[test]
    fn test_stale_guidance_contains_commands() {
        let mut output = String::new();
        generate_stale_guidance(&mut output);

        assert!(output.contains("agentlens"));
        assert!(output.contains("agentlens --diff main"));
        assert!(output.contains("agentlens --check"));
        assert!(output.contains("agentlens --force"));
    }
}

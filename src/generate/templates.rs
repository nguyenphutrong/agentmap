//! AI tool template generation for Cursor, Claude Code, and OpenCode.
//!
//! Generates configuration templates that instruct AI tools to use agentlens documentation.

use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TemplateType {
    Cursor,
    Claude,
    OpenCode,
}

impl TemplateType {
    pub fn parse(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "cursor" | "cursorrules" | ".cursorrules" => Some(TemplateType::Cursor),
            "claude" | "claude.md" | "claudecode" => Some(TemplateType::Claude),
            "opencode" | "agents.md" | "agents" => Some(TemplateType::OpenCode),
            _ => None,
        }
    }

    pub fn all() -> Vec<TemplateType> {
        vec![
            TemplateType::Cursor,
            TemplateType::Claude,
            TemplateType::OpenCode,
        ]
    }

    pub fn filename(&self) -> &'static str {
        match self {
            TemplateType::Cursor => ".cursorrules",
            TemplateType::Claude => "CLAUDE.md",
            TemplateType::OpenCode => "AGENTS.md",
        }
    }

    pub fn display_name(&self) -> &'static str {
        match self {
            TemplateType::Cursor => "Cursor",
            TemplateType::Claude => "Claude Code",
            TemplateType::OpenCode => "OpenCode",
        }
    }
}

impl fmt::Display for TemplateType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.display_name())
    }
}

pub struct TemplateConfig<'a> {
    pub project_name: Option<&'a str>,
    pub agentlens_dir: &'a str,
}

impl Default for TemplateConfig<'_> {
    fn default() -> Self {
        Self {
            project_name: None,
            agentlens_dir: ".agentlens",
        }
    }
}

pub fn generate_template(_template_type: TemplateType, config: &TemplateConfig) -> String {
    generate_unified_template(config)
}

fn generate_unified_template(config: &TemplateConfig) -> String {
    let dir = config.agentlens_dir;
    let project_header = config
        .project_name
        .map(|name| format!("# {}\n\n", name))
        .unwrap_or_default();

    format!(
        r#"{project_header}# Agentmap Integration

This project uses **agentlens** for AI-optimized documentation.

## Reading Protocol

Follow this order to understand the codebase efficiently:

1. **Start here**: `{dir}/INDEX.md` - Project overview and module routing
2. **AI instructions**: `{dir}/AGENT.md` - How to use the documentation
3. **Module details**: `{dir}/modules/{{module}}/MODULE.md` - File lists and entry points
4. **Before editing**: Check `{dir}/modules/{{module}}/memory.md` for warnings/TODOs

## Documentation Structure

```
{dir}/
â”œâ”€â”€ INDEX.md              # Start here - global routing table
â”œâ”€â”€ AGENT.md              # AI agent instructions
â”œâ”€â”€ modules/
â”‚   â””â”€â”€ {{module-slug}}/
â”‚       â”œâ”€â”€ MODULE.md     # Module summary
â”‚       â”œâ”€â”€ outline.md    # Symbol maps for large files
â”‚       â”œâ”€â”€ memory.md     # Warnings, TODOs, business rules
â”‚       â””â”€â”€ imports.md    # Dependencies
â””â”€â”€ files/                # Deep docs for complex files
```

## During Development

- Use `{dir}/modules/{{module}}/outline.md` to find symbols in large files
- Check `{dir}/modules/{{module}}/imports.md` for dependencies
- For complex files, see `{dir}/files/{{file-slug}}.md`

## Commands

| Task | Command |
|------|---------|
| Regenerate docs | `agentlens` |
| Fast update (changed only) | `agentlens --diff main` |
| Check if stale | `agentlens --check` |
| Force full regen | `agentlens --force` |

## Key Patterns

- **Module boundaries**: `mod.rs` (Rust), `index.ts` (TS), `__init__.py` (Python)
- **Large files**: >500 lines, have symbol outlines
- **Complex files**: >30 symbols, have L2 deep docs
- **Hub files**: Imported by 3+ files, marked with ðŸ”—
- **Memory markers**: TODO, FIXME, WARNING, SAFETY, RULE

---
*Generated by [agentlens](https://github.com/nguyenphutrong/agentlens)*
"#
    )
}

pub fn parse_template_types(input: &str) -> Option<Vec<TemplateType>> {
    if input.is_empty() || input == "all" {
        return Some(TemplateType::all());
    }

    input
        .split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .map(TemplateType::parse)
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_template_type_parse() {
        assert_eq!(TemplateType::parse("cursor"), Some(TemplateType::Cursor));
        assert_eq!(TemplateType::parse("CURSOR"), Some(TemplateType::Cursor));
        assert_eq!(
            TemplateType::parse(".cursorrules"),
            Some(TemplateType::Cursor)
        );
        assert_eq!(TemplateType::parse("claude"), Some(TemplateType::Claude));
        assert_eq!(TemplateType::parse("CLAUDE.md"), Some(TemplateType::Claude));
        assert_eq!(
            TemplateType::parse("opencode"),
            Some(TemplateType::OpenCode)
        );
        assert_eq!(
            TemplateType::parse("agents.md"),
            Some(TemplateType::OpenCode)
        );
        assert_eq!(TemplateType::parse("invalid"), None);
    }

    #[test]
    fn test_template_type_all() {
        let all = TemplateType::all();
        assert_eq!(all.len(), 3);
        assert!(all.contains(&TemplateType::Cursor));
        assert!(all.contains(&TemplateType::Claude));
        assert!(all.contains(&TemplateType::OpenCode));
    }

    #[test]
    fn test_template_type_filename() {
        assert_eq!(TemplateType::Cursor.filename(), ".cursorrules");
        assert_eq!(TemplateType::Claude.filename(), "CLAUDE.md");
        assert_eq!(TemplateType::OpenCode.filename(), "AGENTS.md");
    }

    #[test]
    fn test_parse_template_types() {
        assert_eq!(parse_template_types(""), Some(TemplateType::all()));
        assert_eq!(parse_template_types("all"), Some(TemplateType::all()));
        assert_eq!(
            parse_template_types("cursor"),
            Some(vec![TemplateType::Cursor])
        );
        assert_eq!(
            parse_template_types("cursor,claude"),
            Some(vec![TemplateType::Cursor, TemplateType::Claude])
        );
        assert_eq!(
            parse_template_types("cursor, claude, opencode"),
            Some(vec![
                TemplateType::Cursor,
                TemplateType::Claude,
                TemplateType::OpenCode
            ])
        );
        assert_eq!(parse_template_types("invalid"), None);
        assert_eq!(parse_template_types("cursor,invalid"), None);
    }

    #[test]
    fn test_generate_template_unified() {
        let config = TemplateConfig::default();

        let cursor = generate_template(TemplateType::Cursor, &config);
        let claude = generate_template(TemplateType::Claude, &config);
        let opencode = generate_template(TemplateType::OpenCode, &config);

        assert_eq!(cursor, claude);
        assert_eq!(claude, opencode);

        assert!(cursor.contains("# Agentmap Integration"));
        assert!(cursor.contains(".agentlens/INDEX.md"));
        assert!(cursor.contains(".agentlens/AGENT.md"));
        assert!(cursor.contains("## Reading Protocol"));
        assert!(cursor.contains("## Documentation Structure"));
        assert!(cursor.contains("## Commands"));
        assert!(cursor.contains("agentlens --check"));
        assert!(cursor.contains("agentlens --diff main"));
    }

    #[test]
    fn test_template_with_custom_config() {
        let config = TemplateConfig {
            project_name: Some("MyProject"),
            agentlens_dir: "docs/ai",
        };

        let result = generate_template(TemplateType::Cursor, &config);
        assert!(result.contains("# MyProject"));
        assert!(result.contains("docs/ai/INDEX.md"));
        assert!(result.contains("docs/ai/AGENT.md"));
    }
}
